// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: torrent.proto

#ifndef PROTOBUF_torrent_2eproto__INCLUDED
#define PROTOBUF_torrent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Torrent {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_torrent_2eproto();
void protobuf_AssignDesc_torrent_2eproto();
void protobuf_ShutdownFile_torrent_2eproto();

class Chunk;
class File;
class Torrent;

// ===================================================================

class Chunk : public ::google::protobuf::Message {
 public:
  Chunk();
  virtual ~Chunk();

  Chunk(const Chunk& from);

  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Chunk& default_instance();

  void Swap(Chunk* other);

  // implements Message ----------------------------------------------

  Chunk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Chunk& from);
  void MergeFrom(const Chunk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string CheckSum = 1;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kCheckSumFieldNumber = 1;
  inline const ::std::string& checksum() const;
  inline void set_checksum(const ::std::string& value);
  inline void set_checksum(const char* value);
  inline void set_checksum(const char* value, size_t size);
  inline ::std::string* mutable_checksum();
  inline ::std::string* release_checksum();
  inline void set_allocated_checksum(::std::string* checksum);

  // required int32 Size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Torrent.Chunk)
 private:
  inline void set_has_checksum();
  inline void clear_has_checksum();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* checksum_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_torrent_2eproto();
  friend void protobuf_AssignDesc_torrent_2eproto();
  friend void protobuf_ShutdownFile_torrent_2eproto();

  void InitAsDefaultInstance();
  static Chunk* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  void Swap(File* other);

  // implements Message ----------------------------------------------

  File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string CheckSum = 1;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kCheckSumFieldNumber = 1;
  inline const ::std::string& checksum() const;
  inline void set_checksum(const ::std::string& value);
  inline void set_checksum(const char* value);
  inline void set_checksum(const char* value, size_t size);
  inline ::std::string* mutable_checksum();
  inline ::std::string* release_checksum();
  inline void set_allocated_checksum(::std::string* checksum);

  // required string RelativePath = 2;
  inline bool has_relativepath() const;
  inline void clear_relativepath();
  static const int kRelativePathFieldNumber = 2;
  inline const ::std::string& relativepath() const;
  inline void set_relativepath(const ::std::string& value);
  inline void set_relativepath(const char* value);
  inline void set_relativepath(const char* value, size_t size);
  inline ::std::string* mutable_relativepath();
  inline ::std::string* release_relativepath();
  inline void set_allocated_relativepath(::std::string* relativepath);

  // required string Filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required int64 Size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // repeated .Torrent.Chunk Chunk = 5;
  inline int chunk_size() const;
  inline void clear_chunk();
  static const int kChunkFieldNumber = 5;
  inline const ::Torrent::Chunk& chunk(int index) const;
  inline ::Torrent::Chunk* mutable_chunk(int index);
  inline ::Torrent::Chunk* add_chunk();
  inline const ::google::protobuf::RepeatedPtrField< ::Torrent::Chunk >&
      chunk() const;
  inline ::google::protobuf::RepeatedPtrField< ::Torrent::Chunk >*
      mutable_chunk();

  // @@protoc_insertion_point(class_scope:Torrent.File)
 private:
  inline void set_has_checksum();
  inline void clear_has_checksum();
  inline void set_has_relativepath();
  inline void clear_has_relativepath();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* checksum_;
  ::std::string* relativepath_;
  ::std::string* filename_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::RepeatedPtrField< ::Torrent::Chunk > chunk_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_torrent_2eproto();
  friend void protobuf_AssignDesc_torrent_2eproto();
  friend void protobuf_ShutdownFile_torrent_2eproto();

  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class Torrent : public ::google::protobuf::Message {
 public:
  Torrent();
  virtual ~Torrent();

  Torrent(const Torrent& from);

  inline Torrent& operator=(const Torrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Torrent& default_instance();

  void Swap(Torrent* other);

  // implements Message ----------------------------------------------

  Torrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Torrent& from);
  void MergeFrom(const Torrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string TorrentId = 1;
  inline bool has_torrentid() const;
  inline void clear_torrentid();
  static const int kTorrentIdFieldNumber = 1;
  inline const ::std::string& torrentid() const;
  inline void set_torrentid(const ::std::string& value);
  inline void set_torrentid(const char* value);
  inline void set_torrentid(const char* value, size_t size);
  inline ::std::string* mutable_torrentid();
  inline ::std::string* release_torrentid();
  inline void set_allocated_torrentid(::std::string* torrentid);

  // required int32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int64 TotalSize = 3;
  inline bool has_totalsize() const;
  inline void clear_totalsize();
  static const int kTotalSizeFieldNumber = 3;
  inline ::google::protobuf::int64 totalsize() const;
  inline void set_totalsize(::google::protobuf::int64 value);

  // required string CreateBy = 4;
  inline bool has_createby() const;
  inline void clear_createby();
  static const int kCreateByFieldNumber = 4;
  inline const ::std::string& createby() const;
  inline void set_createby(const ::std::string& value);
  inline void set_createby(const char* value);
  inline void set_createby(const char* value, size_t size);
  inline ::std::string* mutable_createby();
  inline ::std::string* release_createby();
  inline void set_allocated_createby(::std::string* createby);

  // required string CreateTime = 5;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 5;
  inline const ::std::string& createtime() const;
  inline void set_createtime(const ::std::string& value);
  inline void set_createtime(const char* value);
  inline void set_createtime(const char* value, size_t size);
  inline ::std::string* mutable_createtime();
  inline ::std::string* release_createtime();
  inline void set_allocated_createtime(::std::string* createtime);

  // required string TrackerAddress = 6;
  inline bool has_trackeraddress() const;
  inline void clear_trackeraddress();
  static const int kTrackerAddressFieldNumber = 6;
  inline const ::std::string& trackeraddress() const;
  inline void set_trackeraddress(const ::std::string& value);
  inline void set_trackeraddress(const char* value);
  inline void set_trackeraddress(const char* value, size_t size);
  inline ::std::string* mutable_trackeraddress();
  inline ::std::string* release_trackeraddress();
  inline void set_allocated_trackeraddress(::std::string* trackeraddress);

  // repeated .Torrent.File File = 7;
  inline int file_size() const;
  inline void clear_file();
  static const int kFileFieldNumber = 7;
  inline const ::Torrent::File& file(int index) const;
  inline ::Torrent::File* mutable_file(int index);
  inline ::Torrent::File* add_file();
  inline const ::google::protobuf::RepeatedPtrField< ::Torrent::File >&
      file() const;
  inline ::google::protobuf::RepeatedPtrField< ::Torrent::File >*
      mutable_file();

  // optional string Introduction = 8;
  inline bool has_introduction() const;
  inline void clear_introduction();
  static const int kIntroductionFieldNumber = 8;
  inline const ::std::string& introduction() const;
  inline void set_introduction(const ::std::string& value);
  inline void set_introduction(const char* value);
  inline void set_introduction(const char* value, size_t size);
  inline ::std::string* mutable_introduction();
  inline ::std::string* release_introduction();
  inline void set_allocated_introduction(::std::string* introduction);

  // @@protoc_insertion_point(class_scope:Torrent.Torrent)
 private:
  inline void set_has_torrentid();
  inline void clear_has_torrentid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_totalsize();
  inline void clear_has_totalsize();
  inline void set_has_createby();
  inline void clear_has_createby();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_trackeraddress();
  inline void clear_has_trackeraddress();
  inline void set_has_introduction();
  inline void clear_has_introduction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* torrentid_;
  ::google::protobuf::int64 totalsize_;
  ::std::string* createby_;
  ::std::string* createtime_;
  ::std::string* trackeraddress_;
  ::google::protobuf::RepeatedPtrField< ::Torrent::File > file_;
  ::std::string* introduction_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_torrent_2eproto();
  friend void protobuf_AssignDesc_torrent_2eproto();
  friend void protobuf_ShutdownFile_torrent_2eproto();

  void InitAsDefaultInstance();
  static Torrent* default_instance_;
};
// ===================================================================


// ===================================================================

// Chunk

// required string CheckSum = 1;
inline bool Chunk::has_checksum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Chunk::set_has_checksum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Chunk::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Chunk::clear_checksum() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    checksum_->clear();
  }
  clear_has_checksum();
}
inline const ::std::string& Chunk::checksum() const {
  return *checksum_;
}
inline void Chunk::set_checksum(const ::std::string& value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void Chunk::set_checksum(const char* value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void Chunk::set_checksum(const char* value, size_t size) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  return checksum_;
}
inline ::std::string* Chunk::release_checksum() {
  clear_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checksum_;
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Chunk::set_allocated_checksum(::std::string* checksum) {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  if (checksum) {
    set_has_checksum();
    checksum_ = checksum;
  } else {
    clear_has_checksum();
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 Size = 2;
inline bool Chunk::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Chunk::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Chunk::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Chunk::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 Chunk::size() const {
  return size_;
}
inline void Chunk::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// File

// required string CheckSum = 1;
inline bool File::has_checksum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_checksum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_checksum() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    checksum_->clear();
  }
  clear_has_checksum();
}
inline const ::std::string& File::checksum() const {
  return *checksum_;
}
inline void File::set_checksum(const ::std::string& value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void File::set_checksum(const char* value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void File::set_checksum(const char* value, size_t size) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  return checksum_;
}
inline ::std::string* File::release_checksum() {
  clear_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checksum_;
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void File::set_allocated_checksum(::std::string* checksum) {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  if (checksum) {
    set_has_checksum();
    checksum_ = checksum;
  } else {
    clear_has_checksum();
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string RelativePath = 2;
inline bool File::has_relativepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_relativepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_relativepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_relativepath() {
  if (relativepath_ != &::google::protobuf::internal::kEmptyString) {
    relativepath_->clear();
  }
  clear_has_relativepath();
}
inline const ::std::string& File::relativepath() const {
  return *relativepath_;
}
inline void File::set_relativepath(const ::std::string& value) {
  set_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    relativepath_ = new ::std::string;
  }
  relativepath_->assign(value);
}
inline void File::set_relativepath(const char* value) {
  set_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    relativepath_ = new ::std::string;
  }
  relativepath_->assign(value);
}
inline void File::set_relativepath(const char* value, size_t size) {
  set_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    relativepath_ = new ::std::string;
  }
  relativepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_relativepath() {
  set_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    relativepath_ = new ::std::string;
  }
  return relativepath_;
}
inline ::std::string* File::release_relativepath() {
  clear_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relativepath_;
    relativepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void File::set_allocated_relativepath(::std::string* relativepath) {
  if (relativepath_ != &::google::protobuf::internal::kEmptyString) {
    delete relativepath_;
  }
  if (relativepath) {
    set_has_relativepath();
    relativepath_ = relativepath;
  } else {
    clear_has_relativepath();
    relativepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Filename = 3;
inline bool File::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& File::filename() const {
  return *filename_;
}
inline void File::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void File::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void File::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* File::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void File::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 Size = 4;
inline bool File::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 File::size() const {
  return size_;
}
inline void File::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// repeated .Torrent.Chunk Chunk = 5;
inline int File::chunk_size() const {
  return chunk_.size();
}
inline void File::clear_chunk() {
  chunk_.Clear();
}
inline const ::Torrent::Chunk& File::chunk(int index) const {
  return chunk_.Get(index);
}
inline ::Torrent::Chunk* File::mutable_chunk(int index) {
  return chunk_.Mutable(index);
}
inline ::Torrent::Chunk* File::add_chunk() {
  return chunk_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Torrent::Chunk >&
File::chunk() const {
  return chunk_;
}
inline ::google::protobuf::RepeatedPtrField< ::Torrent::Chunk >*
File::mutable_chunk() {
  return &chunk_;
}

// -------------------------------------------------------------------

// Torrent

// required string TorrentId = 1;
inline bool Torrent::has_torrentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Torrent::set_has_torrentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Torrent::clear_has_torrentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Torrent::clear_torrentid() {
  if (torrentid_ != &::google::protobuf::internal::kEmptyString) {
    torrentid_->clear();
  }
  clear_has_torrentid();
}
inline const ::std::string& Torrent::torrentid() const {
  return *torrentid_;
}
inline void Torrent::set_torrentid(const ::std::string& value) {
  set_has_torrentid();
  if (torrentid_ == &::google::protobuf::internal::kEmptyString) {
    torrentid_ = new ::std::string;
  }
  torrentid_->assign(value);
}
inline void Torrent::set_torrentid(const char* value) {
  set_has_torrentid();
  if (torrentid_ == &::google::protobuf::internal::kEmptyString) {
    torrentid_ = new ::std::string;
  }
  torrentid_->assign(value);
}
inline void Torrent::set_torrentid(const char* value, size_t size) {
  set_has_torrentid();
  if (torrentid_ == &::google::protobuf::internal::kEmptyString) {
    torrentid_ = new ::std::string;
  }
  torrentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torrent::mutable_torrentid() {
  set_has_torrentid();
  if (torrentid_ == &::google::protobuf::internal::kEmptyString) {
    torrentid_ = new ::std::string;
  }
  return torrentid_;
}
inline ::std::string* Torrent::release_torrentid() {
  clear_has_torrentid();
  if (torrentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = torrentid_;
    torrentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torrent::set_allocated_torrentid(::std::string* torrentid) {
  if (torrentid_ != &::google::protobuf::internal::kEmptyString) {
    delete torrentid_;
  }
  if (torrentid) {
    set_has_torrentid();
    torrentid_ = torrentid;
  } else {
    clear_has_torrentid();
    torrentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 Type = 2;
inline bool Torrent::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Torrent::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Torrent::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Torrent::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Torrent::type() const {
  return type_;
}
inline void Torrent::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int64 TotalSize = 3;
inline bool Torrent::has_totalsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Torrent::set_has_totalsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Torrent::clear_has_totalsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Torrent::clear_totalsize() {
  totalsize_ = GOOGLE_LONGLONG(0);
  clear_has_totalsize();
}
inline ::google::protobuf::int64 Torrent::totalsize() const {
  return totalsize_;
}
inline void Torrent::set_totalsize(::google::protobuf::int64 value) {
  set_has_totalsize();
  totalsize_ = value;
}

// required string CreateBy = 4;
inline bool Torrent::has_createby() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Torrent::set_has_createby() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Torrent::clear_has_createby() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Torrent::clear_createby() {
  if (createby_ != &::google::protobuf::internal::kEmptyString) {
    createby_->clear();
  }
  clear_has_createby();
}
inline const ::std::string& Torrent::createby() const {
  return *createby_;
}
inline void Torrent::set_createby(const ::std::string& value) {
  set_has_createby();
  if (createby_ == &::google::protobuf::internal::kEmptyString) {
    createby_ = new ::std::string;
  }
  createby_->assign(value);
}
inline void Torrent::set_createby(const char* value) {
  set_has_createby();
  if (createby_ == &::google::protobuf::internal::kEmptyString) {
    createby_ = new ::std::string;
  }
  createby_->assign(value);
}
inline void Torrent::set_createby(const char* value, size_t size) {
  set_has_createby();
  if (createby_ == &::google::protobuf::internal::kEmptyString) {
    createby_ = new ::std::string;
  }
  createby_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torrent::mutable_createby() {
  set_has_createby();
  if (createby_ == &::google::protobuf::internal::kEmptyString) {
    createby_ = new ::std::string;
  }
  return createby_;
}
inline ::std::string* Torrent::release_createby() {
  clear_has_createby();
  if (createby_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createby_;
    createby_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torrent::set_allocated_createby(::std::string* createby) {
  if (createby_ != &::google::protobuf::internal::kEmptyString) {
    delete createby_;
  }
  if (createby) {
    set_has_createby();
    createby_ = createby;
  } else {
    clear_has_createby();
    createby_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string CreateTime = 5;
inline bool Torrent::has_createtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Torrent::set_has_createtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Torrent::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Torrent::clear_createtime() {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    createtime_->clear();
  }
  clear_has_createtime();
}
inline const ::std::string& Torrent::createtime() const {
  return *createtime_;
}
inline void Torrent::set_createtime(const ::std::string& value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void Torrent::set_createtime(const char* value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void Torrent::set_createtime(const char* value, size_t size) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torrent::mutable_createtime() {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  return createtime_;
}
inline ::std::string* Torrent::release_createtime() {
  clear_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createtime_;
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torrent::set_allocated_createtime(::std::string* createtime) {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    delete createtime_;
  }
  if (createtime) {
    set_has_createtime();
    createtime_ = createtime;
  } else {
    clear_has_createtime();
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string TrackerAddress = 6;
inline bool Torrent::has_trackeraddress() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Torrent::set_has_trackeraddress() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Torrent::clear_has_trackeraddress() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Torrent::clear_trackeraddress() {
  if (trackeraddress_ != &::google::protobuf::internal::kEmptyString) {
    trackeraddress_->clear();
  }
  clear_has_trackeraddress();
}
inline const ::std::string& Torrent::trackeraddress() const {
  return *trackeraddress_;
}
inline void Torrent::set_trackeraddress(const ::std::string& value) {
  set_has_trackeraddress();
  if (trackeraddress_ == &::google::protobuf::internal::kEmptyString) {
    trackeraddress_ = new ::std::string;
  }
  trackeraddress_->assign(value);
}
inline void Torrent::set_trackeraddress(const char* value) {
  set_has_trackeraddress();
  if (trackeraddress_ == &::google::protobuf::internal::kEmptyString) {
    trackeraddress_ = new ::std::string;
  }
  trackeraddress_->assign(value);
}
inline void Torrent::set_trackeraddress(const char* value, size_t size) {
  set_has_trackeraddress();
  if (trackeraddress_ == &::google::protobuf::internal::kEmptyString) {
    trackeraddress_ = new ::std::string;
  }
  trackeraddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torrent::mutable_trackeraddress() {
  set_has_trackeraddress();
  if (trackeraddress_ == &::google::protobuf::internal::kEmptyString) {
    trackeraddress_ = new ::std::string;
  }
  return trackeraddress_;
}
inline ::std::string* Torrent::release_trackeraddress() {
  clear_has_trackeraddress();
  if (trackeraddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trackeraddress_;
    trackeraddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torrent::set_allocated_trackeraddress(::std::string* trackeraddress) {
  if (trackeraddress_ != &::google::protobuf::internal::kEmptyString) {
    delete trackeraddress_;
  }
  if (trackeraddress) {
    set_has_trackeraddress();
    trackeraddress_ = trackeraddress;
  } else {
    clear_has_trackeraddress();
    trackeraddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Torrent.File File = 7;
inline int Torrent::file_size() const {
  return file_.size();
}
inline void Torrent::clear_file() {
  file_.Clear();
}
inline const ::Torrent::File& Torrent::file(int index) const {
  return file_.Get(index);
}
inline ::Torrent::File* Torrent::mutable_file(int index) {
  return file_.Mutable(index);
}
inline ::Torrent::File* Torrent::add_file() {
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Torrent::File >&
Torrent::file() const {
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::Torrent::File >*
Torrent::mutable_file() {
  return &file_;
}

// optional string Introduction = 8;
inline bool Torrent::has_introduction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Torrent::set_has_introduction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Torrent::clear_has_introduction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Torrent::clear_introduction() {
  if (introduction_ != &::google::protobuf::internal::kEmptyString) {
    introduction_->clear();
  }
  clear_has_introduction();
}
inline const ::std::string& Torrent::introduction() const {
  return *introduction_;
}
inline void Torrent::set_introduction(const ::std::string& value) {
  set_has_introduction();
  if (introduction_ == &::google::protobuf::internal::kEmptyString) {
    introduction_ = new ::std::string;
  }
  introduction_->assign(value);
}
inline void Torrent::set_introduction(const char* value) {
  set_has_introduction();
  if (introduction_ == &::google::protobuf::internal::kEmptyString) {
    introduction_ = new ::std::string;
  }
  introduction_->assign(value);
}
inline void Torrent::set_introduction(const char* value, size_t size) {
  set_has_introduction();
  if (introduction_ == &::google::protobuf::internal::kEmptyString) {
    introduction_ = new ::std::string;
  }
  introduction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torrent::mutable_introduction() {
  set_has_introduction();
  if (introduction_ == &::google::protobuf::internal::kEmptyString) {
    introduction_ = new ::std::string;
  }
  return introduction_;
}
inline ::std::string* Torrent::release_introduction() {
  clear_has_introduction();
  if (introduction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = introduction_;
    introduction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torrent::set_allocated_introduction(::std::string* introduction) {
  if (introduction_ != &::google::protobuf::internal::kEmptyString) {
    delete introduction_;
  }
  if (introduction) {
    set_has_introduction();
    introduction_ = introduction;
  } else {
    clear_has_introduction();
    introduction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Torrent

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_torrent_2eproto__INCLUDED
