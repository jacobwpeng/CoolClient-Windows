// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: torrent.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "torrent.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Torrent {

namespace {

const ::google::protobuf::Descriptor* Chunk_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Chunk_reflection_ = NULL;
const ::google::protobuf::Descriptor* File_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  File_reflection_ = NULL;
const ::google::protobuf::Descriptor* Torrent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Torrent_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_torrent_2eproto() {
  protobuf_AddDesc_torrent_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "torrent.proto");
  GOOGLE_CHECK(file != NULL);
  Chunk_descriptor_ = file->message_type(0);
  static const int Chunk_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, checksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, size_),
  };
  Chunk_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Chunk_descriptor_,
      Chunk::default_instance_,
      Chunk_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Chunk));
  File_descriptor_ = file->message_type(1);
  static const int File_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(File, checksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(File, relativepath_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(File, filename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(File, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(File, chunk_),
  };
  File_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      File_descriptor_,
      File::default_instance_,
      File_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(File, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(File, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(File));
  Torrent_descriptor_ = file->message_type(2);
  static const int Torrent_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, torrentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, totalsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, createby_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, createtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, trackeraddress_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, introduction_),
  };
  Torrent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Torrent_descriptor_,
      Torrent::default_instance_,
      Torrent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Torrent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Torrent));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_torrent_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Chunk_descriptor_, &Chunk::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    File_descriptor_, &File::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Torrent_descriptor_, &Torrent::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_torrent_2eproto() {
  delete Chunk::default_instance_;
  delete Chunk_reflection_;
  delete File::default_instance_;
  delete File_reflection_;
  delete Torrent::default_instance_;
  delete Torrent_reflection_;
}

void protobuf_AddDesc_torrent_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rtorrent.proto\022\007Torrent\"\'\n\005Chunk\022\020\n\010Che"
    "ckSum\030\001 \002(\t\022\014\n\004Size\030\002 \002(\005\"m\n\004File\022\020\n\010Che"
    "ckSum\030\001 \002(\t\022\024\n\014RelativePath\030\002 \002(\t\022\020\n\010Fil"
    "ename\030\003 \002(\t\022\014\n\004Size\030\004 \002(\003\022\035\n\005Chunk\030\005 \003(\013"
    "2\016.Torrent.Chunk\"\256\001\n\007Torrent\022\021\n\tTorrentI"
    "d\030\001 \002(\t\022\014\n\004Type\030\002 \002(\005\022\021\n\tTotalSize\030\003 \002(\003"
    "\022\020\n\010CreateBy\030\004 \002(\t\022\022\n\nCreateTime\030\005 \002(\t\022\026"
    "\n\016TrackerAddress\030\006 \002(\t\022\033\n\004File\030\007 \003(\0132\r.T"
    "orrent.File\022\024\n\014Introduction\030\010 \001(\t", 353);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "torrent.proto", &protobuf_RegisterTypes);
  Chunk::default_instance_ = new Chunk();
  File::default_instance_ = new File();
  Torrent::default_instance_ = new Torrent();
  Chunk::default_instance_->InitAsDefaultInstance();
  File::default_instance_->InitAsDefaultInstance();
  Torrent::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_torrent_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_torrent_2eproto {
  StaticDescriptorInitializer_torrent_2eproto() {
    protobuf_AddDesc_torrent_2eproto();
  }
} static_descriptor_initializer_torrent_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Chunk::kCheckSumFieldNumber;
const int Chunk::kSizeFieldNumber;
#endif  // !_MSC_VER

Chunk::Chunk()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Chunk::InitAsDefaultInstance() {
}

Chunk::Chunk(const Chunk& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Chunk::SharedCtor() {
  _cached_size_ = 0;
  checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Chunk::~Chunk() {
  SharedDtor();
}

void Chunk::SharedDtor() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  if (this != default_instance_) {
  }
}

void Chunk::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Chunk::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Chunk_descriptor_;
}

const Chunk& Chunk::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_torrent_2eproto();
  return *default_instance_;
}

Chunk* Chunk::default_instance_ = NULL;

Chunk* Chunk::New() const {
  return new Chunk;
}

void Chunk::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_checksum()) {
      if (checksum_ != &::google::protobuf::internal::kEmptyString) {
        checksum_->clear();
      }
    }
    size_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Chunk::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string CheckSum = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_checksum()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->checksum().data(), this->checksum().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Size;
        break;
      }

      // required int32 Size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Chunk::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string CheckSum = 1;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->checksum().data(), this->checksum().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->checksum(), output);
  }

  // required int32 Size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Chunk::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string CheckSum = 1;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->checksum().data(), this->checksum().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->checksum(), target);
  }

  // required int32 Size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Chunk::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string CheckSum = 1;
    if (has_checksum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->checksum());
    }

    // required int32 Size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Chunk::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Chunk* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Chunk*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Chunk::MergeFrom(const Chunk& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_checksum()) {
      set_checksum(from.checksum());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Chunk::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Chunk::CopyFrom(const Chunk& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chunk::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Chunk::Swap(Chunk* other) {
  if (other != this) {
    std::swap(checksum_, other->checksum_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Chunk::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Chunk_descriptor_;
  metadata.reflection = Chunk_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int File::kCheckSumFieldNumber;
const int File::kRelativePathFieldNumber;
const int File::kFilenameFieldNumber;
const int File::kSizeFieldNumber;
const int File::kChunkFieldNumber;
#endif  // !_MSC_VER

File::File()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void File::InitAsDefaultInstance() {
}

File::File(const File& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void File::SharedCtor() {
  _cached_size_ = 0;
  checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  relativepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  size_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

File::~File() {
  SharedDtor();
}

void File::SharedDtor() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  if (relativepath_ != &::google::protobuf::internal::kEmptyString) {
    delete relativepath_;
  }
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (this != default_instance_) {
  }
}

void File::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* File::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return File_descriptor_;
}

const File& File::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_torrent_2eproto();
  return *default_instance_;
}

File* File::default_instance_ = NULL;

File* File::New() const {
  return new File;
}

void File::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_checksum()) {
      if (checksum_ != &::google::protobuf::internal::kEmptyString) {
        checksum_->clear();
      }
    }
    if (has_relativepath()) {
      if (relativepath_ != &::google::protobuf::internal::kEmptyString) {
        relativepath_->clear();
      }
    }
    if (has_filename()) {
      if (filename_ != &::google::protobuf::internal::kEmptyString) {
        filename_->clear();
      }
    }
    size_ = GOOGLE_LONGLONG(0);
  }
  chunk_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool File::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string CheckSum = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_checksum()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->checksum().data(), this->checksum().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_RelativePath;
        break;
      }

      // required string RelativePath = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_RelativePath:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_relativepath()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->relativepath().data(), this->relativepath().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_Filename;
        break;
      }

      // required string Filename = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Filename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filename().data(), this->filename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_Size;
        break;
      }

      // required int64 Size = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_Chunk;
        break;
      }

      // repeated .Torrent.Chunk Chunk = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Chunk:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_chunk()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_Chunk;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void File::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string CheckSum = 1;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->checksum().data(), this->checksum().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->checksum(), output);
  }

  // required string RelativePath = 2;
  if (has_relativepath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->relativepath().data(), this->relativepath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->relativepath(), output);
  }

  // required string Filename = 3;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->filename(), output);
  }

  // required int64 Size = 4;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->size(), output);
  }

  // repeated .Torrent.Chunk Chunk = 5;
  for (int i = 0; i < this->chunk_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->chunk(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* File::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string CheckSum = 1;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->checksum().data(), this->checksum().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->checksum(), target);
  }

  // required string RelativePath = 2;
  if (has_relativepath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->relativepath().data(), this->relativepath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->relativepath(), target);
  }

  // required string Filename = 3;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->filename(), target);
  }

  // required int64 Size = 4;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->size(), target);
  }

  // repeated .Torrent.Chunk Chunk = 5;
  for (int i = 0; i < this->chunk_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->chunk(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int File::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string CheckSum = 1;
    if (has_checksum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->checksum());
    }

    // required string RelativePath = 2;
    if (has_relativepath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->relativepath());
    }

    // required string Filename = 3;
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filename());
    }

    // required int64 Size = 4;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->size());
    }

  }
  // repeated .Torrent.Chunk Chunk = 5;
  total_size += 1 * this->chunk_size();
  for (int i = 0; i < this->chunk_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->chunk(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void File::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const File* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const File*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void File::MergeFrom(const File& from) {
  GOOGLE_CHECK_NE(&from, this);
  chunk_.MergeFrom(from.chunk_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_checksum()) {
      set_checksum(from.checksum());
    }
    if (from.has_relativepath()) {
      set_relativepath(from.relativepath());
    }
    if (from.has_filename()) {
      set_filename(from.filename());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void File::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void File::CopyFrom(const File& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool File::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  for (int i = 0; i < chunk_size(); i++) {
    if (!this->chunk(i).IsInitialized()) return false;
  }
  return true;
}

void File::Swap(File* other) {
  if (other != this) {
    std::swap(checksum_, other->checksum_);
    std::swap(relativepath_, other->relativepath_);
    std::swap(filename_, other->filename_);
    std::swap(size_, other->size_);
    chunk_.Swap(&other->chunk_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata File::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = File_descriptor_;
  metadata.reflection = File_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Torrent::kTorrentIdFieldNumber;
const int Torrent::kTypeFieldNumber;
const int Torrent::kTotalSizeFieldNumber;
const int Torrent::kCreateByFieldNumber;
const int Torrent::kCreateTimeFieldNumber;
const int Torrent::kTrackerAddressFieldNumber;
const int Torrent::kFileFieldNumber;
const int Torrent::kIntroductionFieldNumber;
#endif  // !_MSC_VER

Torrent::Torrent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Torrent::InitAsDefaultInstance() {
}

Torrent::Torrent(const Torrent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Torrent::SharedCtor() {
  _cached_size_ = 0;
  torrentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  totalsize_ = GOOGLE_LONGLONG(0);
  createby_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  trackeraddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  introduction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Torrent::~Torrent() {
  SharedDtor();
}

void Torrent::SharedDtor() {
  if (torrentid_ != &::google::protobuf::internal::kEmptyString) {
    delete torrentid_;
  }
  if (createby_ != &::google::protobuf::internal::kEmptyString) {
    delete createby_;
  }
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    delete createtime_;
  }
  if (trackeraddress_ != &::google::protobuf::internal::kEmptyString) {
    delete trackeraddress_;
  }
  if (introduction_ != &::google::protobuf::internal::kEmptyString) {
    delete introduction_;
  }
  if (this != default_instance_) {
  }
}

void Torrent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Torrent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Torrent_descriptor_;
}

const Torrent& Torrent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_torrent_2eproto();
  return *default_instance_;
}

Torrent* Torrent::default_instance_ = NULL;

Torrent* Torrent::New() const {
  return new Torrent;
}

void Torrent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_torrentid()) {
      if (torrentid_ != &::google::protobuf::internal::kEmptyString) {
        torrentid_->clear();
      }
    }
    type_ = 0;
    totalsize_ = GOOGLE_LONGLONG(0);
    if (has_createby()) {
      if (createby_ != &::google::protobuf::internal::kEmptyString) {
        createby_->clear();
      }
    }
    if (has_createtime()) {
      if (createtime_ != &::google::protobuf::internal::kEmptyString) {
        createtime_->clear();
      }
    }
    if (has_trackeraddress()) {
      if (trackeraddress_ != &::google::protobuf::internal::kEmptyString) {
        trackeraddress_->clear();
      }
    }
    if (has_introduction()) {
      if (introduction_ != &::google::protobuf::internal::kEmptyString) {
        introduction_->clear();
      }
    }
  }
  file_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Torrent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string TorrentId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_torrentid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->torrentid().data(), this->torrentid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Type;
        break;
      }

      // required int32 Type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_TotalSize;
        break;
      }

      // required int64 TotalSize = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TotalSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &totalsize_)));
          set_has_totalsize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_CreateBy;
        break;
      }

      // required string CreateBy = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_CreateBy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_createby()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->createby().data(), this->createby().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_CreateTime;
        break;
      }

      // required string CreateTime = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_CreateTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_createtime()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->createtime().data(), this->createtime().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_TrackerAddress;
        break;
      }

      // required string TrackerAddress = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_TrackerAddress:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trackeraddress()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->trackeraddress().data(), this->trackeraddress().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_File;
        break;
      }

      // repeated .Torrent.File File = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_File:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_file()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_File;
        if (input->ExpectTag(66)) goto parse_Introduction;
        break;
      }

      // optional string Introduction = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Introduction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_introduction()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->introduction().data(), this->introduction().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Torrent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string TorrentId = 1;
  if (has_torrentid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->torrentid().data(), this->torrentid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->torrentid(), output);
  }

  // required int32 Type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // required int64 TotalSize = 3;
  if (has_totalsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->totalsize(), output);
  }

  // required string CreateBy = 4;
  if (has_createby()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->createby().data(), this->createby().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->createby(), output);
  }

  // required string CreateTime = 5;
  if (has_createtime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->createtime().data(), this->createtime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->createtime(), output);
  }

  // required string TrackerAddress = 6;
  if (has_trackeraddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trackeraddress().data(), this->trackeraddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->trackeraddress(), output);
  }

  // repeated .Torrent.File File = 7;
  for (int i = 0; i < this->file_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->file(i), output);
  }

  // optional string Introduction = 8;
  if (has_introduction()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->introduction().data(), this->introduction().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->introduction(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Torrent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string TorrentId = 1;
  if (has_torrentid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->torrentid().data(), this->torrentid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->torrentid(), target);
  }

  // required int32 Type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->type(), target);
  }

  // required int64 TotalSize = 3;
  if (has_totalsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->totalsize(), target);
  }

  // required string CreateBy = 4;
  if (has_createby()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->createby().data(), this->createby().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->createby(), target);
  }

  // required string CreateTime = 5;
  if (has_createtime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->createtime().data(), this->createtime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->createtime(), target);
  }

  // required string TrackerAddress = 6;
  if (has_trackeraddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trackeraddress().data(), this->trackeraddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->trackeraddress(), target);
  }

  // repeated .Torrent.File File = 7;
  for (int i = 0; i < this->file_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->file(i), target);
  }

  // optional string Introduction = 8;
  if (has_introduction()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->introduction().data(), this->introduction().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->introduction(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Torrent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string TorrentId = 1;
    if (has_torrentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->torrentid());
    }

    // required int32 Type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required int64 TotalSize = 3;
    if (has_totalsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->totalsize());
    }

    // required string CreateBy = 4;
    if (has_createby()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->createby());
    }

    // required string CreateTime = 5;
    if (has_createtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->createtime());
    }

    // required string TrackerAddress = 6;
    if (has_trackeraddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trackeraddress());
    }

    // optional string Introduction = 8;
    if (has_introduction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->introduction());
    }

  }
  // repeated .Torrent.File File = 7;
  total_size += 1 * this->file_size();
  for (int i = 0; i < this->file_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->file(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Torrent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Torrent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Torrent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Torrent::MergeFrom(const Torrent& from) {
  GOOGLE_CHECK_NE(&from, this);
  file_.MergeFrom(from.file_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_torrentid()) {
      set_torrentid(from.torrentid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_totalsize()) {
      set_totalsize(from.totalsize());
    }
    if (from.has_createby()) {
      set_createby(from.createby());
    }
    if (from.has_createtime()) {
      set_createtime(from.createtime());
    }
    if (from.has_trackeraddress()) {
      set_trackeraddress(from.trackeraddress());
    }
    if (from.has_introduction()) {
      set_introduction(from.introduction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Torrent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Torrent::CopyFrom(const Torrent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Torrent::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  for (int i = 0; i < file_size(); i++) {
    if (!this->file(i).IsInitialized()) return false;
  }
  return true;
}

void Torrent::Swap(Torrent* other) {
  if (other != this) {
    std::swap(torrentid_, other->torrentid_);
    std::swap(type_, other->type_);
    std::swap(totalsize_, other->totalsize_);
    std::swap(createby_, other->createby_);
    std::swap(createtime_, other->createtime_);
    std::swap(trackeraddress_, other->trackeraddress_);
    file_.Swap(&other->file_);
    std::swap(introduction_, other->introduction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Torrent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Torrent_descriptor_;
  metadata.reflection = Torrent_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Torrent

// @@protoc_insertion_point(global_scope)
